<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ローグっぽい何か コード解説ドキュメント</title>
  <style>
    /* 背景と全体のフォント */
    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: radial-gradient(circle at top left, #ffebcd, #f4a460);
      margin: 20px;
      color: #333;
      line-height: 1.6;
    }
    /* ヘッダーの装飾 */
    h1, h2, h3 {
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      color: #d2691e;
    }
    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }
    h2 {
      font-size: 2em;
      margin-top: 40px;
    }
    h3 {
      font-size: 1.6em;
      margin-top: 30px;
    }
    /* セクションの余白 */
    .section {
      background: rgba(255,255,255,0.8);
      border: 2px dashed #ff7f50;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 40px;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
    }
    /* コードブロックのスタイル */
    pre {
      background: #fff8dc;
      padding: 15px;
      border: 1px solid #deb887;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 14px;
      box-shadow: 1px 1px 5px rgba(0,0,0,0.1);
    }
    code {
      font-family: Consolas, "Courier New", monospace;
      color: #8b4513;
    }
    /* 楽しいメモ風のスタイル */
    .note {
      background-color: #ffefd5;
      border-left: 6px solid #ff6347;
      padding: 10px 15px;
      margin: 15px 0;
      border-radius: 8px;
      font-style: italic;
    }
    /* リンクボタン風の装飾 */
    a.button {
      background-color: #ff7f50;
      color: #fff;
      padding: 8px 15px;
      text-decoration: none;
      border-radius: 20px;
      font-weight: bold;
      transition: background-color 0.3s ease;
    }
    a.button:hover {
      background-color: #ff6347;
    }
  </style>
</head>
<body>
  <h1>ローグっぽい何か コード解説ドキュメント</h1>
  <p>本ドキュメントは、HTML/CSS/JavaScriptで実装されたローグライクゲームのプログラムコードに基づいた解説資料です。各セクションでは、プログラムの構造や主要なクラス、関数のサンプルコードと共に、その役割や仕組みについて詳しく説明しています。（&#8203;:contentReference[oaicite:0]{index=0}&#8203;:contentReference[oaicite:1]{index=1}）</p>
  
  <div class="section">
    <h2>1. 基本</h2>
    <p>このゲームは、HTMLでキャンバス部分を用意し、CSSでシンプルなスタイリングを行い、JavaScriptでゲームロジックを実装しています。まずは各基本要素を見ていきます。</p>
    
    <h3>1.1 CONFIG オブジェクト</h3>
    <p>ゲーム全体のパラメータ（マップサイズ、初期体力、各種ターンサイクルなど）を管理する定数オブジェクトです。</p>
    <pre><code>const CONFIG = {
  WIDTH: 40,
  HEIGHT: 32,
  INITIAL_HP: 8,
  REST_CYCLE: 5,
  GENERATE_ENEMY_CYCLE: 30,
  HUNGER_CYCLE: 5,
  MIN_ENEMY_MULTIPLIER: 1.1,
  MAX_ENEMY_MULTIPLIER: 1.4,
};</code></pre>
    
    <h3>1.2 エンティティクラス</h3>
    <p>ゲーム内の各キャラクターやアイテムはクラスとして実装されています。ここでは、<code>BaseEntity</code> を基本として、<code>Player</code> や <code>Enemy</code>、<code>Food</code> が派生しています。</p>
    <pre><code>// BaseEntity: 全エンティティの基本クラス
class BaseEntity {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

// Player: プレイヤーのステータスを管理
class Player extends BaseEntity {
  constructor(x, y, initialHP) {
    super(x, y);
    this.hp = initialHP;
    this.maxHp = initialHP;
    this.attack = 2;
    this.healAmount = 3;
    this.level = 1;
    this.exp = 0;
    this.hunger = 100;
    this.maxHunger = 100;
  }
}</code></pre>
    
    <h3>1.3 DungeonMap クラス</h3>
    <p>ダンジョンの自動生成と部屋同士の接続、視界管理を行うクラスです。下記は部屋生成部分の抜粋です。</p>
    <pre><code>class DungeonMap {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.grid = [];
    this.visible = [];
    this.rooms = [];
    this.reset();
  }
  reset() {
    this.grid = Array.from({ length: this.height }, () => Array(this.width).fill('🌳'));
    this.visible = Array.from({ length: this.height }, () => Array(this.width).fill(false));
    this.rooms = [];
  }
  createRoom() {
    let w = randomInt(5, 10);
    let h = randomInt(4, 8);
    let x = randomInt(1, this.width - w - 1);
    let y = randomInt(1, this.height - h - 1);
    for (let i = y; i < y + h; i++) {
      for (let j = x; j < x + w; j++) {
        this.grid[i][j] = ' '; // 空白タイル
      }
    }
    this.rooms.push({ x, y, w, h });
  }
  // ... その他のメソッド
}</code></pre>
  </div>
  
  <div class="section">
    <h2>2. 応用</h2>
    <p>基本部分に加え、ゲーム内の動作を支える応用的な処理について解説します。ここでは、ターン制の進行、非同期処理、敵のAIなどが含まれます。</p>
    
    <h3>2.1 ターン進行と非同期処理</h3>
    <p>ゲームの各ターンごとに敵の生成やハンガーの更新、休憩による体力回復が行われます。これらは <code>advanceTurn()</code> や <code>queueTimeout()</code> で管理されています。</p>
    <pre><code>class Game {
  // ターン進行処理
  advanceTurn() {
    this.generateEnemyCycle[0] = (this.generateEnemyCycle[0] + 1) % this.generateEnemyCycle[1];
    this.hungerCycle[0] = (this.hungerCycle[0] + 1) % this.hungerCycle[1];
  }

  // 非同期キュー処理で、動作のタイミングを調整
  queueTimeout(callback, delay) {
    this.acceptingInput = false;
    const id = setTimeout(() => {
      callback();
      this.timeoutQueue = this.timeoutQueue.filter(t => t !== id);
      if (this.timeoutQueue.length === 0) this.acceptingInput = true;
      this.render();
    }, delay);
    this.timeoutQueue.push(id);
  }
}</code></pre>
    
    <h3>2.2 敵の移動アルゴリズム</h3>
    <p>敵はプレイヤーに向かって移動し、接近すると攻撃を仕掛けます。移動方向の決定と障害物チェックを行う処理が特徴です。</p>
    <pre><code>moveEnemies(nextPlayerX, nextPlayerY) {
  this.enemies.forEach((enemy, idx) => {
    // プレイヤーとの距離計算
    const dx = Math.abs(enemy.x - this.player.x);
    const dy = Math.abs(enemy.y - this.player.y);
    // 近接している場合、攻撃処理
    this.queueTimeout(() => {
      if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
        this.player.hp--;
        EffectsManager.showEffect(this.gameContainer, this.player.x, this.player.y, "-1", "damage-me");
        return;
      }
    }, 100);
    // プレイヤーに向かう方向を算出
    const dirX = Math.sign(this.player.x - enemy.x);
    const dirY = Math.sign(this.player.y - enemy.y);
    // 壁や他の敵との衝突判定
    // ...（省略）
  });
}</code></pre>
    
    <div class="note">
      <p><strong>注:</strong> 非同期処理を利用することで、ユーザーの入力とエフェクト表示のタイミング調整が可能になり、ゲーム体験がスムーズに実現されています。</p>
    </div>
  </div>
  
  <div class="section">
    <h2>3. 拡張</h2>
    <p>現在のコードをベースに、さらなる機能追加や改良を行うためのアイディアについて解説します。</p>
    
    <h3>3.1 新たな敵やアイテムの実装</h3>
    <p>基本的な <code>Enemy</code> クラスに加えて、特殊能力を持った敵や多彩なアイテム（例：一時的な攻撃強化やシールド効果など）を実装することで、ゲームの深みが増します。以下は、拡張用のサンプルコード例です。</p>
    <pre><code>// 拡張: 範囲攻撃を持つ特殊な敵クラス
class SpecialEnemy extends Enemy {
  constructor(x, y, hp) {
    super(x, y, hp);
    this.attackRange = 2;
  }
  // プレイヤーに対して範囲攻撃を行う処理
  areaAttack(player, gameContainer) {
    if (Math.abs(this.x - player.x) <= this.attackRange &&
        Math.abs(this.y - player.y) <= this.attackRange) {
      player.hp -= 2;
      EffectsManager.showEffect(gameContainer, player.x, player.y, "-2", "damage-me");
    }
  }
}</code></pre>
    
    <h3>3.2 マップ生成アルゴリズムの改良</h3>
    <p>現在はシンプルな部屋生成と直線的な通路接続ですが、より複雑なダンジョン（例：分岐や隠し部屋）を生成するアルゴリズムを導入することで、探索要素が強化されます。以下は改良の一例です。</p>
    <pre><code>// 改良例: ランダムウォークを利用したダンジョン生成
generateMaze() {
  // 初期グリッドの準備
  for (let y = 0; y < this.height; y++) {
    for (let x = 0; x < this.width; x++) {
      this.grid[y][x] = '🌳';
    }
  }
  // ランダムウォークで通路を生成
  let x = randomInt(1, this.width - 2);
  let y = randomInt(1, this.height - 2);
  for (let i = 0; i < 1000; i++) {
    this.grid[y][x] = ' ';
    const direction = randomInt(0, 3);
    if (direction === 0 && x > 1) x--;
    else if (direction === 1 && x < this.width - 2) x++;
    else if (direction === 2 && y > 1) y--;
    else if (direction === 3 && y < this.height - 2) y++;
  }
}</code></pre>
    
    <h3>3.3 UI・エフェクトの強化</h3>
    <p>グラフィックやサウンドを充実させるため、Canvas API や Web Audio API を利用した実装が考えられます。現行コードの <code>EffectsManager</code> をベースに、より多彩なアニメーションやエフェクトの実装が可能です。</p>
  </div>
  
  <h2>まとめ</h2>
  <p>本プログラムはシンプルながら多くの基本要素（ターン進行、ダンジョン生成、エフェクト、衝突判定など）を実装しており、さらに拡張の余地が大いにあります。各セクションのサンプルコードを参考に、新たな機能追加や改良を試みてみてください。</p>
  
  <div class="note">
    <p>※ 本ドキュメントのサンプルコードは実際のプログラムの一部抜粋および拡張例です。実装環境や追加機能に合わせて適宜調整してください。</p>
  </div>
  
  <p>楽しいコードライフを！ <a class="button" href="#">もっと学ぶ</a></p>
  
</body>
</html>
